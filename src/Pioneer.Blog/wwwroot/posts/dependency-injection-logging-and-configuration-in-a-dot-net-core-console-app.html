<!doctype html>
<html class="no-js" lang="">
<head>
  <link href="/app.css" rel="stylesheet" />
  <script src="/app.js"></script>
</head>
<body>
  <div class="row">
    <div class="large-10 large-push-1 columns">
      <article>
        <p>With .NET Core, we get a lot of stuff for free.  If you so choose, wiring up your applications (ASP.NET or Console) with things like Dependency Injection, Configuration and Logging is as simple as can be.  .NET Core bakes these features into the framework and usage of does not require a trade off of power or flexibility. </p>
        <p>Following, I will walk you through getting up and running with all three of these items in a .NET Core console application.</p>
        <h2>Setup</h2>
        <h3>Project</h3>
        <p>First thing first, lets create a new project.  Open up Visual Studio, hit <b>Ctrl+Shift+N</b> and select the <b>Console Application (.NET Core) project type from the templates,</b></p>
        <img src="../images/dependency-injection-logging-and-configuration-in-a-dot-net-core-console-app/create-project.png" title="Create Project" style="max-width: 941px;" />
        <br />
        <br />
        <p>Visual studio will scaffold a project for you which will end up looking like this.</p>
        <img src="../images/dependency-injection-logging-and-configuration-in-a-dot-net-core-console-app/project.png" title="New Console Project" style="max-width: 297px;" />
        <br />
        <br />
        <h3>Dependencies</h3>
        <p>.NET Core is all about opting into dependencies as opposed to opting out.  That being said we will need to pull in a few nuget packages to facilitate our needs. Open up your <b>project.json</b> file and add the following packages to your dependencies node. Versions might differ depending on what version of .NET Core you are using.</p>
        <pre class="brush: json">  "dependencies": {
    "Microsoft.NETCore.App": "1.1.0",
    "Microsoft.Extensions.DependencyInjection": "1.1.0",
    "Microsoft.Extensions.Configuration.Json": "1.1.0",
    "Microsoft.Extensions.Configuration.FileExtensions": "1.1.0",
    "Microsoft.Extensions.Configuration": "1.1.0",
    "Microsoft.Extensions.Options.ConfigurationExtensions": "1.1.0",
    "Microsoft.Extensions.Logging": "1.1.0",
    "Microsoft.Extensions.Logging.Console": "1.1.0",
    "Microsoft.Extensions.Logging.Debug": "1.1.0"
  },
</pre>
        <p class="note">Fair warning, <b>project.json</b> is on its way out in favor of <b>.csproj</b>. As of the date this was published, this transition is already in the Visual Studio 2017 release candidate.</p>
        <h2>Dependency Injection</h2>
        <p>Now that our project is ready, we need to wire up our dependency injection container so we have a means to register the individual components we will be using in our program. For this demonstration, we will be registering a new service called <b>TestService</b>.  Go ahead and create a new file called <b>TestService.cs</b> and add the following.</p>
        <pre class="brush: csharp">public interface ITestService
{
}
class TestService : ITestService
{
}</pre>
        <p>To maintain a separation of concern between our business based logic and the logic we use to configure and run the actual counsel application, lets create a new class called <b>App.cs</b>. The goal being that we will use <b>Program.cs</b> to bootstrap everything need to support our application and then fire off all the logic that is needed to support out "business" needs by way of executing the <b>Run()</b> method in <b>App.cs</b>.</p>
        <pre class="brush: csharp">public class App
{
    private readonly ITestService _testService;
    public App(ITestService testService)
    {
        _testService = testService;
    }
    public void Run()
    {
        _testService.Run();
        System.Console.ReadKey();
    }
}</pre>
        <p><b>App.cs</b> need an object that meets the <b>ITestService</b> interface contract.  This object will be passed in through our dependency manager.</p>
        <p>Open up your <b>Program.cs</b> file and add the following.</p>
        <pre class="brush: csharp">public class Program
{
    public static void Main(string[] args)
    {
        // create service collection
        var serviceCollection = new ServiceCollection();
        ConfigureServices(serviceCollection);
        // create service provider
        var serviceProvider = serviceCollection.BuildServiceProvider();
        // entry to run app
        serviceProvider.GetService&lt;App&gt;().Run();
    }
    private static void ConfigureServices(IServiceCollection serviceCollection)
    {
        // add services
        serviceCollection.AddTransient&lt;ITestService, TestService&gt;();
        // add app
        serviceCollection.AddTransient&lt;App&gt;();
    }
}</pre>
        <p>Our console app starts out in <b>Main</b>.  Hear we create a new <b>ServiceCollection</b> object and configure it inside of <b>ConfigureServices</b>.  In <b>ConfigureServices</b> we add our dependences to the container collection, of which can have a lifetime of <b>Scoped</b>, <b>Transient</b> or <b>Singleton</b>. Once the <b>ServiceCollection</b> object is configured, we  then need to request a <b>IServiceProvider</b> (Dependency Management Container) from our <b>ServiceCollection</b> object in order to manually resolve our <b>App</b> class and kick our logical loop off by calling its <b>Run()</b> method.</p>
        <p class="note">For more information on service lifetime and registration options, visit <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection#service-lifetimes-and-registration-options" target="_blank" title=".NET Core Dependency Options">.NET Dependency Injection</a>.</p>
        <h2>Logging</h2>
        <p>Now that we have our Dependency Injection wired up, we need to setup logging. More specifically, we need to log to the console so that we can visually verify that not only our <b>App.Run()</b> method is being called but also that our <b>ITestService</b> is being injected and ran from the <b>App</b> class.</p>
        <h3>Setup</h3>
        <p>Open of <b>Program.cs</b> again and update the <b>ConfigureServices</b> method with the following.</p>
        <pre class="brush: csharp">private static void ConfigureServices(IServiceCollection serviceCollection)
{
    // add logging
    serviceCollection.AddSingleton(new LoggerFactory()
    .AddConsole()
    .AddDebug());
    serviceCollection.AddLogging(); 
    // add services
    serviceCollection.AddTransient&lt;ITestService, TestService&gt;();
    // add app
    serviceCollection.AddTransient&lt;App&gt;();
}</pre>
        <p>We first add new instances of <b>ILoggerFactory</b> for the <b>Console</b> (outputs to the console) and <b>Debug</b> (writes log output by way of System.Diagnostics.Debug) providers. Both providers will have a <b>Singleton</b> lifetime.  Finally we add our logging services to your service collection.</p>
        <h4>Usage</h4>
        <p>Update the <b>App</b> class with the following.</p>
        <pre class="brush: csharp">    public class App
    {
        private readonly ITestService _testService;
        private readonly ILogger&lt;App&gt; _logger;
        public App(ITestService testService,
            ILogger&lt;App&gt; logger)
        {
            _testService = testService;
            _logger = logger;
        }
        public void Run()
        {
            _logger.LogInformation($"This is a console application for {_config.Title}");
            _testService.Run();
            System.Console.ReadKey();
        }
    }</pre>
        <p>We now are injecting an instance of <b>ILogger&lt;App&gt;</b>. Of which we are using to <b>LogInfromation</b> inside our <b>Run()</b> method.  Additionally, we are calling the <b>ITestService.Run()</b> of our injected service to further illustrate that our dependency injection is actually managing dependencies correctly. </p>
        <p>Update the <b>TestService</b> class and interface with the following.</p>
        <pre class="brush: csharp">public interface ITestService
{
    void Run();
}
class TestService : ITestService
{
    private readonly ILogger&lt;TestService&gt; _logger;
    public TestService(ILogger&lt;TestService&gt; logger)
    {
        _logger = logger;
    }
    public void Run()
    {
        _logger.LogWarning("Wow! We are now in the test service.");
    }
}</pre>
        <p>Much like <b,>App.cs</b,> we inject an instance of <b>ILogger&lt;TestService&gt;</b> and perform a <b>LogWarning</b> inside of <b>ITestService.Run()</b>.</p>
        <p>If we run our console app now, we should end up with something like the following.  Of which shows our path down to the <b>ITestService</b> instance through our logging.</p>
        <img src="../images/dependency-injection-logging-and-configuration-in-a-dot-net-core-console-app/console-1.png" title="Console with logging." style="max-width: 504px" />
        <br />
        <br />
        <h2>Configuration</h2>
        <p>Typically you will need some kind of configuration to manage your apps deployment.  Luckily, .NET Core offers up a clean and lightweight method of pulling in configuration through a json file.</p>
        <p>Create a file called <b>app-settings.json</b> and add the following.</p>
        <pre class="brush: json">{
  "Configuration": {
    "Title": "Pioneer Console Boilerplate"
  }
}</pre>
        <p>Create a file called <b>AppSettings.cs</b> and add the following. We will use this model to deserialize our <b>app-settings.json</b> file into.</p>
        <pre class="brush: csharp">public class AppSettings
{
    public string Title { get; set; }
}</pre>
        <p>Update <b>Program.ConfigureServices</b> with the following.</p>
        <pre class="brush: csharp">private static void ConfigureServices(IServiceCollection serviceCollection)
{
    // add configured instance of logging
    serviceCollection.AddSingleton(new LoggerFactory()
        .AddConsole()
        .AddDebug());
    // add logging
    serviceCollection.AddLogging(); 
    // build configuration
    var configuration = new ConfigurationBuilder()
        .SetBasePath(Directory.GetCurrentDirectory())
        .AddJsonFile("app-settings.json", false)
        .Build();
    serviceCollection.AddOptions();
    serviceCollection.Configure&lt;AppSettings&gt;(configuration.GetSection("Configuration"));
    // add services 
    serviceCollection.AddTransient&lt;ITestService, TestService&gt;();
    // add app
    serviceCollection.AddTransient&lt;App&gt;();
}</pre>
        <p>We use a <b>ConfigurationBuilder</b> object to...</p>
        <ol>
          <li>Set a absolute path scoped to the directory our <b>app-settings.json</b> file lives.</li>
          <li>Add our <b>app-settings.json</b> file to <b>IConfigurationRoot</b> object, denoting it as not-optional. </li>
          <li>Build and return our <b>IConfigurationRoot</b> object.</li>
        </ol>
        <p>We then call <b>AddOptions()</b> on our <b>IServiceCollection</b> object to add services needed to use the <b><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#options-config-objects" title="Options Pattern" target="_blank.">Options</a></b> pattern inside of our app.  In short, the <b><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/configuration#options-config-objects" title="Options Pattern" target="_blank.">Options Pattern</a></b> allows us to decouple feature configuration in our application and bind said feature configuration to independent models.</p>
        <p>Finally we register the <b>IConfigurationRoot</b> instance, which our <b>Options</b> will bind against.</p>
        <h3>Usage</h3>
        <p>Open up your <b>App</b> class and update it with the following.</p>
        <pre class="brush: csharp">public class App
{
    private readonly ITestService _testService;
    private readonly ILogger&lt;App&gt; _logger;
    private readonly AppSettings _config;
    public App(ITestService testService,
        IOptions&lt;AppSettings&gt; config,
        ILogger&lt;App&gt; logger)
    {
        _testService = testService;
        _logger = logger;
        _config = config.Value;
    }
    public void Run()
    {
        _logger.LogInformation($"This is a console application for {_config.Title}");
        _testService.Run();
        System.Console.ReadKey();
    }
}</pre>
        <p>Open up your <b>TestService</b> class and update it with the following.</p>
      <pre class="brush: csharp">class TestService : ITestService
{
    private readonly ILogger&lt;TestService&gt; _logger;
    private readonly AppSettings _config;
    public TestService(ILogger&lt;TestService&gt; logger,
        IOptions&lt;AppSettings&gt; config)
    {
        _logger = logger;
        _config = config.Value;
    }
    public void Run()
    {
        _logger.LogWarning($"Wow! We are now in the test service of: {_config.Title}");
    }
}</pre>
      <p>In both updates, we inject an <b>IOptions&lt;t&gt;</b> with a type of <b>AppSettings</b>. This means we will get an object that has our <b>app-settings.json</b> config file deserialized into said object.  Of which, we use to print our <b>Title</b> variable out with our logging message.</p>
      <p>Run the application and you should now get something that looks like this.</p>
      </article>
    </div>
  </div>
</body>
</html>